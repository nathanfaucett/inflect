var util = require("util"),
	
	fs = require("fs"),
	path = require("path"),
	
	cwd = process.cwd(),
	isArray = Array.isArray,
	
	crypto = require("crypto"),
	UID_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
	UID_CHARS_LENGTH = UID_CHARS.length,
	
	floor = Math.floor,
	random = Math.random,
	
	ObjectProto = Object.prototype,
	toString = ObjectProto.toString,
	hasOwnProperty = ObjectProto.hasOwnProperty,
	
	diveDefaultOpts = {
		all: false,
		recursive: true,
		files: true,
		directories: false
	},
	
	SIGN_REPLACER = /\=+$/;


function isEmpty(obj) {
	if (isArray(obj) || isString(obj)) return obj.length === 0;
	for (var key in obj) if (has(obj, key)) return false;
	return true;
}
util.isEmpty = isEmpty;


function isObject(obj) {
	
	return obj === Object(obj);
}
util.isObject = isObject;


function isArrayLike(obj) {
	
	return typeof(obj) === "object" && typeof(obj.length) === "number";
}
util.isArrayLike = isArrayLike;
util.isArray = isArray;


function isArguments(obj) {
	
	return toString.call(obj) === "[object Arguments]";
}
util.isArguments = isArguments;


function isFunction(obj) {
	
	return typeof(obj) === "function"
}
util.isFunction = isFunction;


function isString(obj) {
	
	return toString.call(obj) === "[object String]";
}
util.isString = isString;


function isNumber(obj) {
	
	return toString.call(obj) === "[object Number]";
}
util.isNumber = isNumber;


function isDecimal(obj) {
	
	return isNumber(obj) && obj % 1 !== 0;
}
util.isDecimal = isDecimal;


function isInteger(obj) {
	
	return isNumber(obj) && obj % 1 === 0;
}
util.isInteger = isInteger;


function isDate(obj) {
	
	return toString.call(obj) === "[object Date]";
}
util.isDate = isDate;


function isRegExp(obj) {
	
	return toString.call(obj) === "[object RegExp]";
}
util.isRegExp = isRegExp;


util.isFinite = isFinite;


util.isNaN = isNaN;


function isBoolean(obj) {
	
	return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}
util.isBoolean = isBoolean;


function isNull(obj) {
	
	return obj === null;
}
util.isNull = isNull;


function isUndefined(obj) {
	
	return obj === void 0;
}
util.isUndefined = isUndefined;


function has(obj, key) {
	
	return hasOwnProperty.call(obj, key)
}
util.has = has;


var amp = /&(?!\w+;)/g,
	lessThan = /</g,
	greaterThan = />/g,
	quot = /"/g;
function escape(str) {
	
	return String(str).replace(amp, "&amp;").replace(lessThan, "&lt;").replace(greaterThan, "&gt;").replace(quot, "&quot;");
}
util.escape = escape;


function arraySubtract(obj, sub) {
    var i, j;
	
    for (i = sub.length; i--;) for (j = obj.length; j--;) {
		if (obj[i] === sub[j]) obj.splice(i, 1);
	}
	
    return obj;
}
util.arraySubtract = arraySubtract;


function flattenArray(array, out){
    isArray(out) || (out = []);
	var item,
		i, il;
	
	for (i = 0 , il = array.length; i < il; i++) {
		
		if (isArray((item = array[i]))) {
			flattenArray(item, out);
		} else {
			out.push(item);
		}
	}
	
	return out;
}
util.flattenArray = flattenArray;


function uid(length) {
	length || (length = 24);
	var out = "",
		bytes = crypto.pseudoRandomBytes(length),
		i;
	
	for (i = length; i--;) out += UID_CHARS[bytes[i] % UID_CHARS_LENGTH];
	return out;
}
util.uid = uid;


function prng(length) {
	length || (length = 24);
	var out = "",
		i;
	
	for (i = length; i--;) out += UID_CHARS[floor(random()*UID_CHARS_LENGTH)];
	return out;
}
util.prng = prng;


function merge(obj, add){
	var key;
	
	for (key in add) if (obj[key] === undefined) obj[key] = add[key];
	
	return obj;
}
util.merge = merge;


function copy(obj) {
    var c = {}, key;
	
    for (key in obj) c[key] = obj[key];
	
    return c;
}
util.copy = copy;


function dive(dir, opts, action, complete){
	if (typeof(opts) === "function") {
		if (typeof(action) === "undefined") {
			complete = function() {};
		}
		else {
			complete = action;
		}
		
		action = opts;
		opts = {};
	} else if (typeof(complete) === "undefined") {
		complete = function() {};
	}
	
	if (typeof(dir) !== "string") dir = cwd;
	merge(opts, diveDefaultOpts);
	
	function doDive(dir) {
		
		fs.readdir(dir, function(err, files) {
			todo--;
			if (err) {
				action(err);
				return;
			}
			
			files.every(function(file) {
				
				if (opts.all || file[0] !== ".") {
					todo++;
					var fullPath = path.resolve(dir, file);
					
					fs.stat(fullPath, function(err, stat) {
						if (err) {
							todo--;
							return action(err);
						}
						
						if (stat) {
							if (stat.isDirectory()) {
								if (opts.directories) return action(null, fullPath);
								if (opts.recursive) doDive(fullPath);
							} else {
								if (opts.files) return action(null, fullPath);
								if (!--todo) complete();
							}
						}
						
						return true;
					});
				}
			});
			
			if (!todo) complete();
		});
	}
	
	var todo = 1;
	doDive(dir);
}
util.dive = dive;


function diveSync(dir, opts, action){
	if (typeof(opts) === "function") {
		action = opts;
		opts = {};
	}
	
	if (typeof(dir) !== "string") dir = cwd;
	merge(opts, diveDefaultOpts);
	
	function doDive(dir) {
		var files;
		
		todo--;
		try{
			files = fs.readdirSync(dir);
		} catch(e) {
			return action(e);
		}
		
		return files.every(function(file) {
			
			if (opts.all || file[0] !== ".") {
				todo++;
				
				var fullPath = path.resolve(dir, file),
					stat;
				
				try{
					stat = fs.statSync(fullPath);
				} catch(e) {
					todo--;
					return action(e);
				}
				
				if (stat) {
					if (stat.isDirectory()) {
						if (opts.directories) return action(null, fullPath);
						if (opts.recursive) return doDive(fullPath);
					} else {
						if (opts.files) return action(null, fullPath);
					}
				}
			}
			
			return true;
		});
	}
	
	var todo = 1;
	doDive(dir);
}
util.diveSync = diveSync;


function fsCopy(dir, dest, complete){
	
	dir = path.resolve(cwd, dir);
	dest = path.resolve(cwd, dest);
	
	dive(dir, function(err, fullPath) {
		if (err) {
			console.warn(err);
			return;
		}
		var pathName = fullPath.substring(dir.length);
		if (pathName[0] === "/") pathName = "."+ pathName;
		pathName = path.resolve(dest, pathName);
		
		fs.readFile(fullPath, function(err, buffer) {
			if (err) {
				console.warn(err);
				return;
			}
			var dirName = path.dirname(pathName);
			
			if (fs.existsSync(dirName)) {
				fs.writeFileSync(pathName, buffer);
			} else {
				fs.mkdir(dirName, 493, function(err) {
					
					fs.writeFileSync(pathName, buffer);
				});
			}
		});
	}, complete);
}
util.fsCopy = fsCopy;


function sign(value, secret) {
	
	return value + "." + crypto.createHmac("sha256", secret).update(value).digest("base64").replace(SIGN_REPLACER, "");
}
util.sign = sign;


function unsign(value, secret) {
	var str = value.slice(0, value.lastIndexOf("."));
	
	return sign(str, secret) === value ? str : false;
}
util.unsign = unsign;


module.exports = util;